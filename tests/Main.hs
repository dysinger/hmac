{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RankNTypes #-}

import qualified Data.ByteString.Char8 as B
import           Test.Hspec
import           Test.Hspec.Attoparsec
import           Test.Tasty
import           Test.Tasty.Hspec
import           Network.HMAC

main :: IO ()
main = do
    tests <-
        testGroup "all" <$>
        sequence
            [ idParserSpec
            , tsParserSpec
            , nonceParserSpec
            , extParserSpec
            , macParserSpec
            , authHeaderParserSpec]
    defaultMain tests

{-

https://tools.ietf.org/html/draft-ietf-oauth-v2-http-mac-01#section-3.1

   The header attributes are set as follows:

   id
         REQUIRED.  The MAC key identifier.
   ts
         REQUIRED.  The request timestamp.  The value MUST be a positive
         integer set by the client when making each request to the
         number of seconds elapsed from a fixed point in time (e.g.
         January 1, 1970 00:00:00 GMT).  The value MUST NOT include
         leading zeros (e.g. "000273154346").
   nonce
         REQUIRED.  A unique string generated by the client.  The value
         MUST be unique across all requests with the same timestamp and
         MAC key identifier combination.
   ext
         OPTIONAL.  A string used to include additional information
         which is covered by the request MAC.  The content and format of
         the string is beyond the scope of this specification.
   mac
         REQUIRED.  The HTTP request MAC as described in Section 3.2.

   Attributes MUST NOT appear more than once.  Attribute values are
   limited to a subset of ASCII, which does not require escaping, as
   defined by the plain-string ABNF.

-}

idParserSpec :: IO TestTree
idParserSpec = do
    testSpec "HMAC Auth Header ID Parser" $
        do describe "id k/v parser" $
               do it "id key should be lower case" $
                      do idParser `shouldFailOn` ("ID=abc" :: B.ByteString)
                         idParser `shouldFailOn` ("Id=abc" :: B.ByteString)
                  it "id value is required" $
                      do idParser `shouldFailOn` ("id" :: B.ByteString)
                         idParser `shouldFailOn` ("id=" :: B.ByteString)
                  it "id value should be plain-string" $
                      do ("id=abc" :: B.ByteString) ~> idParser `shouldParse`
                             (ID "abc")
                         ("id=123" :: B.ByteString) ~> idParser `shouldParse`
                             (ID "123")
                         ("id=abc123" :: B.ByteString) ~> idParser `shouldParse`
                             (ID "abc123")

tsParserSpec :: IO TestTree
tsParserSpec = do
    testSpec "HMAC Auth Header TS Parser" $
        do describe "ts k/v parser" $
               do it "ts key should be lower case" $
                      do tsParser `shouldFailOn` ("TS=abc" :: B.ByteString)
                         tsParser `shouldFailOn` ("Ts=abc" :: B.ByteString)
                  it "ts value is required" $
                      do tsParser `shouldFailOn` ("ts" :: B.ByteString)
                         tsParser `shouldFailOn` ("ts=" :: B.ByteString)
                  it "ts value should be an integer" $
                      do ("ts=123" :: B.ByteString) ~> tsParser `shouldParse`
                             (TS 123)
                  it "should fail to parse numbers with leading zeros" $
                      do 1 `shouldBe` 1

nonceParserSpec :: IO TestTree
nonceParserSpec = do
    testSpec "HMAC Auth Header Nonce Parser" $
        do describe "nonce k/v parser" $
               do it "nonce value should be plain-string" $
                      do ("nonce=xyz123" :: B.ByteString) ~> nonceParser `shouldParse`
                             (Nonce "xyz123")
                  it "nonce value is required" $
                      do nonceParser `shouldFailOn` ("nonce" :: B.ByteString)
                         nonceParser `shouldFailOn` ("nonce=" :: B.ByteString)
                  it "nonce value should be plain-string" $
                      do ("nonce=abc" :: B.ByteString) ~> nonceParser `shouldParse`
                             (Nonce "abc")
                         ("nonce=123" :: B.ByteString) ~> nonceParser `shouldParse`
                             (Nonce "123")
                         ("nonce=abc123" :: B.ByteString) ~> nonceParser `shouldParse`
                             (Nonce "abc123")

extParserSpec :: IO TestTree
extParserSpec = do
    testSpec "HMAC Auth Header Ext Parser" $
        do describe "ext k/v parser" $
               do it "ext value is required (if key is present)" $
                      do extParser `shouldFailOn` ("ext" :: B.ByteString)
                         extParser `shouldFailOn` ("ext=" :: B.ByteString)
                  it "ext value should be plain-string" $
                      do ("ext=abc" :: B.ByteString) ~> extParser `shouldParse`
                             (Ext "abc")
                         ("ext=123" :: B.ByteString) ~> extParser `shouldParse`
                             (Ext "123")
                         ("ext=abc123" :: B.ByteString) ~> extParser `shouldParse`
                             (Ext "abc123")

macParserSpec :: IO TestTree
macParserSpec = do
    testSpec "HMAC Auth Header Mac Parser" $
        do describe "mac k/v parser" $
               do it "mac value is required" $
                      do macParser `shouldFailOn` ("mac" :: B.ByteString)
                         macParser `shouldFailOn` ("mac=" :: B.ByteString)
                  it "mac value should be plain-string" $
                      do ("mac=abc" :: B.ByteString) ~> macParser `shouldParse`
                             (Mac "abc")
                         ("mac=123" :: B.ByteString) ~> macParser `shouldParse`
                             (Mac "123")
                         ("mac=abc123" :: B.ByteString) ~> macParser `shouldParse`
                             (Mac "abc123")

authHeaderParserSpec :: IO TestTree
authHeaderParserSpec =
    testSpec "HMAC Auth Header Parser" $
    do describe "auth header parser" $
           do it "auth header should have id, ts, nonce and mac k/v" $
                  do authParser `shouldFailOn` ("id=abc" :: B.ByteString)
                     authParser `shouldFailOn`
                         ("id=abc ts=123" :: B.ByteString)
                     authParser `shouldFailOn`
                         ("id=abc ts=123 nonce=abc" :: B.ByteString)
                     authParser `shouldFailOn`
                         ("id=abc ts=123 nonce=abc ext=123" :: B.ByteString)
                     ("id=abc" :: B.ByteString) ~>
                         authParser `shouldParse`
                         (Authorization (ID "abc")
                          -- { id' = ID "abc"
                          -- -- , ts = TS 123
                          -- -- , nonce = Nonce "abc123"
                          -- -- , ext = Nothing
                          -- -- , mac = Mac "123abc"
                          -- }
                         )

-- headerVerificationSpec :: IO TestTree
-- headerVerificationSpec =
--     testSpec "HMAC Header Verification" $
--     do describe "checking the presence of the 'Authorization' header" $
--            do context "when present" $
--                   do it "should have contents verified" $ do 1 `shouldBe` 1
--               context "when missing" $
--                   do it "should return an error" $ do 1 `shouldBe` 1
--        describe "checking the value of the 'Authorization' header" $
--            do context "when checking the 'id' key/value" $
--                   do it "should be present (REQUIRED)" $
--                          do 1 `shouldBe` 1
--                      it "there should be only 1" $
--                          do 1 `shouldBe` 1
--                      it "should be a valid ASCII subset" $
--                          do 1 `shouldBe` 1
--               context "when checking the 'ts' key/value" $
--                   do it "should be present (REQUIRED)" $
--                          do 1 `shouldBe` 1
--                      it "there should be only 1" $
--                          do 1 `shouldBe` 1
--                      it "should be a valid positive integer" $
--                          do 1 `shouldBe` 1
--                      it "should not contain leading zeros" $
--                          do 1 `shouldBe` 1
--               context "when checking the 'nonce' key/value" $
--                   do it "should be present (REQUIRED)" $
--                          do 1 `shouldBe` 1
--                      it "there should be only 1" $
--                          do 1 `shouldBe` 1
--                      it "should be a valid ASCII subset" $
--                          do 1 `shouldBe` 1
--               context "when checking the 'ext' key/value" $
--                   do it "could be present (OPTIONAL)" $
--                          do 1 `shouldBe` 1
--                      it "there should be only 1 if present" $
--                          do 1 `shouldBe` 1
