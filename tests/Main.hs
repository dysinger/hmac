{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RankNTypes #-}

import qualified Data.ByteString.Char8 as B
import           Test.Hspec
import           Test.Hspec.Attoparsec
import           Test.Tasty
import           Test.Tasty.Hspec
import           Network.HMAC.Parse
import           Network.HMAC.Types

main :: IO ()
main = do
    tests <-
        testGroup "all" <$>
        sequence
            [ idParserSpec
            , tsParserSpec
            , nonceParserSpec
            , extParserSpec
            , macParserSpec
            , authHeaderParserSpec]
    defaultMain tests

{-

https://tools.ietf.org/html/draft-ietf-oauth-v2-http-mac-01#section-3.1

   The header attributes are set as follows:

   id
         REQUIRED.  The MAC key identifier.
   ts
         REQUIRED.  The request timestamp.  The value MUST be a positive
         integer set by the client when making each request to the
         number of seconds elapsed from a fixed point in time (e.g.
         January 1, 1970 00:00:00 GMT).  The value MUST NOT include
         leading zeros (e.g. "000273154346").
   nonce
         REQUIRED.  A unique string generated by the client.  The value
         MUST be unique across all requests with the same timestamp and
         MAC key identifier combination.
   ext
         OPTIONAL.  A string used to include additional information
         which is covered by the request MAC.  The content and format of
         the string is beyond the scope of this specification.
   mac
         REQUIRED.  The HTTP request MAC as described in Section 3.2.

   Attributes MUST NOT appear more than once.  Attribute values are
   limited to a subset of ASCII, which does not require escaping, as
   defined by the plain-string ABNF.

-}

idParserSpec :: IO TestTree
idParserSpec = do
    testSpec "HMAC Auth Header ID Parser" $
        do describe "id k/v parser" $
               do it "id key should be lower case" $
                      do idP `shouldFailOn` ("ID=abc" :: B.ByteString)
                         idP `shouldFailOn` ("Id=abc" :: B.ByteString)
                  it "id value is required" $
                      do idP `shouldFailOn` ("id" :: B.ByteString)
                         idP `shouldFailOn` ("id=" :: B.ByteString)
                  it "id value should be plain-string" $
                      do ("id=abc" :: B.ByteString) ~> idP `shouldParse`
                             (ID "abc")
                         ("id=123" :: B.ByteString) ~> idP `shouldParse`
                             (ID "123")
                         ("id=abc123" :: B.ByteString) ~> idP `shouldParse`
                             (ID "abc123")

tsParserSpec :: IO TestTree
tsParserSpec = do
    testSpec "HMAC Auth Header TS Parser" $
        do describe "ts k/v parser" $
               do it "ts key should be lower case" $
                      do tsP `shouldFailOn` ("TS=abc" :: B.ByteString)
                         tsP `shouldFailOn` ("Ts=abc" :: B.ByteString)
                  it "ts value is required" $
                      do tsP `shouldFailOn` ("ts" :: B.ByteString)
                         tsP `shouldFailOn` ("ts=" :: B.ByteString)
                  it "ts value should be an integer" $
                      do ("ts=123" :: B.ByteString) ~> tsP `shouldParse`
                             (TS 123)
                  -- it "should fail to parse numbers with leading zeros" $
                  --     do 1 `shouldBe` 1

nonceParserSpec :: IO TestTree
nonceParserSpec = do
    testSpec "HMAC Auth Header Nonce Parser" $
        do describe "nonce k/v parser" $
               do it "nonce value should be plain-string" $
                      do ("nonce=xyz123" :: B.ByteString) ~> nonceP `shouldParse`
                             (Nonce "xyz123")
                  it "nonce value is required" $
                      do nonceP `shouldFailOn` ("nonce" :: B.ByteString)
                         nonceP `shouldFailOn` ("nonce=" :: B.ByteString)
                  it "nonce value should be plain-string" $
                      do ("nonce=abc" :: B.ByteString) ~> nonceP `shouldParse`
                             (Nonce "abc")
                         ("nonce=123" :: B.ByteString) ~> nonceP `shouldParse`
                             (Nonce "123")
                         ("nonce=abc123" :: B.ByteString) ~> nonceP `shouldParse`
                             (Nonce "abc123")

extParserSpec :: IO TestTree
extParserSpec = do
    testSpec "HMAC Auth Header Ext Parser" $
        do describe "ext k/v parser" $
               do it "ext value is required (if key is present)" $
                      do extP `shouldFailOn` ("ext" :: B.ByteString)
                         extP `shouldFailOn` ("ext=" :: B.ByteString)
                  it "ext value should be plain-string" $
                      do ("ext=abc" :: B.ByteString) ~> extP `shouldParse`
                             (Ext "abc")
                         ("ext=123" :: B.ByteString) ~> extP `shouldParse`
                             (Ext "123")
                         ("ext=abc123" :: B.ByteString) ~> extP `shouldParse`
                             (Ext "abc123")

macParserSpec :: IO TestTree
macParserSpec = do
    testSpec "HMAC Auth Header Mac Parser" $
        do describe "mac k/v parser" $
               do it "mac value is required" $
                      do macP `shouldFailOn` ("mac" :: B.ByteString)
                         macP `shouldFailOn` ("mac=" :: B.ByteString)
                  it "mac value should be plain-string" $
                      do ("mac=abc" :: B.ByteString) ~> macP `shouldParse`
                             (Mac "abc")
                         ("mac=123" :: B.ByteString) ~> macP `shouldParse`
                             (Mac "123")
                         ("mac=abc123" :: B.ByteString) ~> macP `shouldParse`
                             (Mac "abc123")

authHeaderParserSpec :: IO TestTree
authHeaderParserSpec =
    testSpec "HMAC Auth Header Parser" $
    do describe "auth header parser" $
           do it "auth header should have id, ts, nonce and mac k/v" $
                  do authP `shouldFailOn` ("id=123" :: B.ByteString) --
                     authP `shouldFailOn` ("id=abc ts=123" :: B.ByteString)
                     authP `shouldFailOn`
                         ("id=xyz ts=123 nonce=abc" :: B.ByteString)
                     authP `shouldFailOn`
                         ("id=egf ts=456 nonce=pqr ext=789" :: B.ByteString)
                     ("id=lol ts=890 nonce=487 mac=af0" :: B.ByteString) ~>
                         authP `shouldParse`
                         Authorization
                             (ID "lol")
                             (TS 890)
                             (Nonce "487")
                             Nothing
                             (Mac "af0")
              it "auth header can have an optional ext k/v" $
                  do ("id=heh ts=837 nonce=298 ext=lol mac=eff" :: B.ByteString) ~>
                         authP `shouldParse`
                         Authorization
                             (ID "heh")
                             (TS 837)
                             (Nonce "298")
                             (Just (Ext "lol"))
                             (Mac "eff")
